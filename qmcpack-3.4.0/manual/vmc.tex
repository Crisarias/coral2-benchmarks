\section{Variational Monte Carlo}
\label{sec:vmc}

\begin{table}[h]
\begin{center}
\begin{tabularx}{\textwidth}{l l l l l l }
\hline
\multicolumn{6}{l}{\texttt{vmc} method} \\
\hline
\multicolumn{2}{l}{parameters}  & \multicolumn{4}{l}{}\\
   &   \bfseries name     & \bfseries datatype & \bfseries values & \bfseries default   & \bfseries description \\
   &   \texttt{walkers             } &  integer  & $> 0$   & dep.& number of walkers per node  \\
   &   \texttt{blocks              } &  integer  & $\ge 0$ & 1   & number of blocks            \\
   &   \texttt{steps               } &  integer  & $\ge 0$ & 1   & number of steps per block   \\
   &   \texttt{warmupsteps         } &  integer  & $\ge 0$ & 0   & number of steps for warming up\\
   &   \texttt{substeps            } &  integer  & $\ge 0$ & 1   & number of substeps per step \\
   &   \texttt{usedrift            } &  text     & yes, no & no  & use the algorithm with drift\\
   &   \texttt{timestep            } &  real     & $> 0$   & 0.1 & time step for each electron move \\
   &   \texttt{samples             } &  integer  & $\ge 0$ & 0   & total number of samples \\
   &   \texttt{stepsbetweensamples } &  integer  & $> 0$   & 1   & period of the sample accumulation\\
   &   \texttt{samplesperthread    } &  integer  & $\ge 0$ & 0   & number of samples per thread  \\
   &   \texttt{storeconfigs        } &  integer  & all values & 0   & store configurations  \\
   &   \texttt{blocks\_between\_recompute} &  integer  & $\ge 0$ & dep.  & wavefunction recompute frequency  \\
  \hline
\end{tabularx}
\end{center}
\end{table}

Additional information:
\begin{itemize}
\item \texttt{walkers}. The initial default number of walkers is 1 but in the CPU branch this number will be overwritten as the number of OpenMP threads if the user requested number is smaller than the number of threads.

\item \texttt{blocks}. This parameter is universal for all the method. At the end of each block, all the statistics accumulated in the block is dumped in to files, e.g.\ scalar.dat.

\item \texttt{warmupsteps}. Warm-up steps are steps used only for equilibration. All the samples generated by warm-up steps are discarded. In practice, there's no need to use many walm-up steps because we can always discard more statistics when we perform the post-process.

\item \texttt{substeps}. In a substep, each of the electrons is moved only once by either particle-by-particle or all-electron move.
Because the local energy is evaluated not at each substep but at each step, increasing the number of substeps doesn't accumulate more samples. But in order to reduce the correlation between consecutive samples, increasing substeps is a very good option for its cheaper computational cost.

\item \texttt{usedrift}. The VMC is implemented in two algorithms with or without drift. In the no-drift algorithm, the move of each electron is proposed with a Gaussian distribution. The standard deviation is chosen as the timestep input. In the drift algorithm, electrons are moved by langevin dynamics.

\item \texttt{timestep}. The meaning of timestep depends on whether the drift is used or not. In general, larger timestep reduces the time correlation but might also reduces the accept ratio. Users are required to check the accept ratio of the calculation and make sure it's larger than 0.9 or between 0.2 and 0.8 with or without the drift.

\item \texttt{stepsbetweensamples}. Due to the fact that samples generated by consecutive steps might be still correlated. Having stepsbetweensamples larger than 1 reduces that correlation. In practice, using larger substeps is cheaper than using stepsbetweensamples to decorrelate samples.

\item \texttt{samples}. This is the total amount of samples generated in the current VMC session. This parameter is not important for VMC only calculation but necessary if optimization or DMC follows.
\[
\textrm{samples}=
\frac{\textrm{blocks}\cdot\textrm{steps}\cdot\textrm{walkers}}{\textrm{stepsbetweensamples}}\cdot\textrm{number of MPI tasks}
\]

\item \texttt{samplesperthread}. This is an alternative way to set the target amount of samples. More useful in the VMC session preparing the population for the following DMC calculation.
\[
\textrm{samplesperthread}=
\frac{\textrm{blocks}\cdot\textrm{steps}}{\textrm{stepsbetweensamples}}
\]
\item \texttt{storeconfigs}. If storeconfigs is set to a non-zero value, then electron configurations during the VMC run will be saved to the files.

\item \texttt{blocks\_between\_recompute}. For every few blocks, recompute the accuracy critical part of the wavefunction from scratch. =1 by default when using mixed precision. =0 (no recompute) by default when not using mixed precision. Recomputing introduces a performance penalty but it is small using $>1$ recompute period.

The following is an example of VMC section.
\begin{lstlisting}
  <qmc method="vmc" move="pbyp" gpu="yes">
    <estimator name="LocalEnergy" hdf5="no"/>
    <parameter name="walkers">    256 </parameter>
    <parameter name="samples">    2867200 </parameter>
    <parameter name="stepsbetweensamples">    1 </parameter>
    <parameter name="substeps">  5 </parameter>
    <parameter name="warmupSteps">  5 </parameter>
    <parameter name="blocks">  70 </parameter>
    <parameter name="timestep">  1.0 </parameter>
    <parameter name="usedrift">   no </parameter>
  </qmc>
\end{lstlisting}


\end{itemize}
